
<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Javascript by kxkyll</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Javascript</h1>
          <h2>4. viikko</h2>
        </header>
	
	<p><em>Tekijät:</em> Marko Haanranta, Kasper Kivikataja,  Kati Kyllönen, Jussi Miestamo</p>

	<p>
		<a href="index.html">Pääsivu</a> <br />
		<a href="week2.html">2. viikko</a> <br />
		<a href="week3.html">3. viikko</a> <br />
		<a href="week4.html">4. viikko</a> <br />
	</p>
  <h2>
<a name="23-hyvi%C3%A4-ohjelmointik%C3%A4yt%C3%A4nt%C3%B6j%C3%A4-oliot-ja-periytyminen" class="anchor" href="#23-hyvi%C3%A4-ohjelmointik%C3%A4yt%C3%A4nt%C3%B6j%C3%A4-oliot-ja-periytyminen"><span class="octicon octicon-link"></span></a>2.3 Hyviä ohjelmointikäytäntöjä: oliot ja periytyminen</h2>

<p>Javascriptin oliot ja periytyminen käsitetään eri tavalla kuin perinteisissä olio-ohjelmointikielissä. Javassa on luokat, joissa määritellään olioiden ominaisuudet, ja yksittäisillä olioilla, jotka ovat luokan ilmentymiä, on arvot noille ominaisuuksille. Luokille voidaan luoda aliluokkia, jotka sitten perivät yliluokkansa ominaisuudet. Aliluokassa voidaan joko muuttaa yliluokan ominaisuuksia tai tuoda aliluokkaan uusia ominaisuuksia yliluokkaan nähden. Aliluokan ilmentymillä on omien ominaisuuksiensa lisäksi myös yliluokan ominaisuudet. Myös Javascriptissä oliot voivat periä toisten olioiden ominaisuuksia, mutta järjestelmä on perustavanlaatuisesti erilainen. Luokkia ei ole. Javascriptissä käytetään prototyyppiperintää. Oliolla on omien ominaisuuksiensa lisäksi prototyyppiolionsa ominaisuudet, jolla on omiensa lisäksi prototyyppiolionsa ominaisuudet, jolla on omiensa lisäksi prototyyppiolionsa ominaisuudet. Ketju jatkuu, kunnes päästään perimysketjun huipulle Object-olioon. Javascriptissä oliot siis perivät toisten olioiden ominaisuuksia eivätkä luokkatasolla määrättyjä ominaisuuksia. Jos on määritelty konstruktori oliolle <code>a</code> ja tuolla konstruktorilla luodaan <code>b</code>, kaikki ne oliot, jotka perivät ominaisuuksia <code>a</code>:lta perivät vain <code>a</code>:n ominaisuudet. Vaikka <code>b</code>:hen lisättäisiin kenttiä, <code>a</code>:n "perilliset" eivät perisi <code>b</code>:n uusia ominaisuuksia.</p>

<p>Mitä ohjelmointityyliin tulee, olio-ohjelmoinnissa pätevät samat säännöt ja tavoitteet kuin olio-ohjelmoinnissa yleensä: reaalimaailman entiteettejä on pyrittävä mallintamaan ohjelmakoodissa, siten että koodi olisi ymmärrettävää, ja ohjelmakoodi on rakennettava niin, että turhaa koodin toistoa ei ole.</p>

<h3>
<a name="231-javascript-ja-oliot" class="anchor" href="#231-javascript-ja-oliot"><span class="octicon octicon-link"></span></a>2.3.1 Javascript ja Oliot</h3>

<p>Eräs määrittely Javascriptin oliolle on seuraava: "Olio on kokoelma ominaisuuksia, joilla on yksi yhteinen prototyyppiolio. Prototyyppi voi olla joko olio tai <code>null</code> [2]." Toisaalta olio voidaan määritellä myös seuraavasti: "Javascriptissä kaikki käyttäytyvät oliomaisesti, paitsi <code>undefined</code> ja <code>null</code> [1]."
Yleisesti mielletään, että oliot ovat funktioiden ilmentymiä, jotka luodaan käyttämällä avainsanaa <code>new</code>. Olioita voi ajatella myös avain-, arvopareina, joita käytetään, kuten Hashmap-tietorakennetta.</p>

<p>Emme löytäneet mitään perusteluja sille, miksi Javascriptin oliosuunnittelussa tulisi poiketa oliosuunnittelun yleisistä periaatteista. Näinollen suosittelemme suunnittelemaan oliot esimerkiksi GRASP-periaatteita noudattaen [7]. Javascript tarjoaa kuitenkin erittäin hyvän suunnittelumallin nimeltä Module-pattern, jonka avulla sovelluksen toimintalogiikkaa voidaan kapseloida hyödyntämällä sulkeumia ja anonyymejä funktioita. Tutustutaan ensin kuitenkin yksinkertaisen olion rakenteeseen.</p>

<p>Esimerkki yksinkertaisesta oliosta ja kuva sen prototyypistä</p>

<div class="highlight"><pre><span class="n">var</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nl">x:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="nl">y:</span> <span class="mi">20</span>
<span class="p">};</span>
</pre></div>

<p><img src="https://raw.github.com/kxkyll/JavaScript/master/images/basic-object.png" alt="Kuva olion prototyypistä"></p>

<p><em>Kuvan alkuperä [2]</em></p>

<p>Käyttämällä olioliteraalinotaatiota<code>{}</code> saadaan luotua tyhjä olio. Vaikka oliolla ei ole omia ominaisuuksia, se perii kuitenkin Object.prototype:n.</p>

<div class="highlight"><pre><span class="n">var</span> <span class="n">empty</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>

<p>Olion nimi osoittaa pointterin tapaan objektin prototyyppiin. Jos oliolta haetaan ominaisuutta, jota sille ei ole määritelty, niin javascript etsii sitä ensin olion omasta prototyypistä.  Etsintää jatketaan prototyyppiketjua seuraten, kunnes lopulta huomataan, että prototyyppiketju on käyty loppuun asti, eikä ominaisuutta ole löytynyt, jolloin palautetaan arvo <code>undefined</code>. Huomionarvoista on, että jos olion prototyypistään perimän attribuutin arvoa yritetään muuttaa, niin prototyypin attribuutin arvo ei muutu. Sen sijaan, oliolle luodaan uusi samanniminen kenttä.
Samoin toimitaan, jos olion "määrittelemättömän" kentän arvoa yritetään muuttaa. </p>

<p>Tässä toinen esimerkki prototyyppiketjuista:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">x</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="nx">calculate</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span>
  <span class="p">}</span>
<span class="p">};</span>
 
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">y</span><span class="o">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="nx">__proto__</span><span class="o">:</span> <span class="nx">a</span>
<span class="p">};</span>
 
<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">y</span><span class="o">:</span> <span class="mi">30</span><span class="p">,</span>
  <span class="nx">__proto__</span><span class="o">:</span> <span class="nx">a</span>
<span class="p">};</span>
 
<span class="c1">// call the inherited method</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">calculate</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span> <span class="c1">// 60</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">calculate</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span> <span class="c1">// 80</span>
</pre></div>

<p><img src="https://raw.github.com/kxkyll/JavaScript/master/images/prototype-chain.png" alt="Kuva prototyyppiketjusta"></p>

<p><em>Kuvan alkuperä [2]</em></p>

<p>Alla oleva esimerkki esittelee this-viittauksen käyttöä:</p>

<div class="highlight"><pre><span class="kd">function</span> <span class="nx">make_person_object</span><span class="p">(</span><span class="nx">firstname</span><span class="p">,</span> <span class="nx">lastname</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">=</span> <span class="nx">firstname</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">lastname</span> <span class="o">=</span> <span class="nx">lastname</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>Esimerkkiobjekteja:</p>

<div class="highlight"><pre><span class="n">var</span> <span class="n">Joe</span> <span class="o">=</span> <span class="n">make_person_object</span><span class="p">(</span><span class="s">"Joe"</span><span class="p">,</span> <span class="s">"Smith"</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span> <span class="c1">// huomaa ei new operaatiota</span>
<span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">Joe</span><span class="p">);</span> <span class="c1">// undefined</span>
</pre></div>
Koska konstruktorifunktio ei tässä palauta luomaansa oliota, <code>Joe</code> ei siirry viittaamaan luotuun olioon, joka häviää bittiavaruuteen. Tilanne voitaisiin korjata liittämällä konstruktorifunktioon <code>return</code>-lause, joka palauttaisi <code>this</code>. Kuitenkin nähdäksemme parempi tapa olisi nähdäksemme:

<div class="highlight"><pre><span class="n">var</span> <span class="n">John</span> <span class="o">=</span> <span class="n">new</span> <span class="n">make_person_object</span><span class="p">(</span><span class="s">"John"</span><span class="p">,</span> <span class="s">"Smith"</span><span class="p">,</span> <span class="mi">45</span><span class="p">);</span> <span class="c1">// new operaatio</span>
<span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">John</span><span class="p">);</span> <span class="c1">// {firstname: "John", lastname: "Smith", age: 45}</span>
</pre></div>

<p>Tässä käytetään <code>new</code>-kutsua, mikä johtaa odotettuun tulokseen eli siihen, että <code>John</code> syntyy. Oikeastaan on sama kumpaa tapaa käyttää, mutta jälkimmäinen tuntuu tutummalta. Varsinaisen ymmärrettävyysongelman tässä aiheuttaa funktion nimentä. Jos funktion nimi on <code>make_person_object</code>, se ohjaa koodaria ajattelemaan, että funktio palauttaisi jotakin. Jos halutaan käyttää tällaista nimeä, funktion pitäisi palauttaa luomansa objekti. Jos taas halutaan käyttää jälkimmäistä tapaa, olisi parempi nimetä funktio <code>Person</code>iksi, koska on intuitiivisempaa luoda uusi "henkilö" kuin luoda uusi "luo uusi henkilö" -objekti.</p>

<p>Nyt voidaan olion prototyypille lisätä greet() metodi, joka käyttää olion parametrejä this viitteen avulla. Tulostuksessa tulostetaan juuri lisätty full_name ja aiemmin olioon asetettu this.firstname.</p>

<div class="highlight"><pre><span class="nx">make_person_object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">greet</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> 
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello! I'm"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">full_name</span><span class="p">,</span> <span class="s2">"Call me"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstname</span><span class="p">);</span> 
<span class="p">};</span>
<span class="nx">John</span><span class="p">.</span><span class="nx">full_name</span> <span class="c1">// "N/A"</span>
<span class="nx">John</span><span class="p">.</span><span class="nx">full_name</span> <span class="o">=</span> <span class="s2">"John Smith"</span><span class="p">;</span> 
<span class="nx">make_person_object</span><span class="p">.</span><span class="nx">full_name</span> <span class="c1">// Still "N/A"</span>
<span class="nx">John</span><span class="p">.</span><span class="nx">greet</span><span class="p">();</span> <span class="c1">// "Hello! I'm John Smith Call me John"</span>
</pre></div>

<p>Javascript-ohjelmoinnissa olisi isoissa projekteissa järkevintä käyttää jo aiemmin mainittua module pattern -suunnittelumallia. Mallin idea on "emuloida" luokkien ideaa, eli kapseloida olioiden sisältö siten, että olion sisäistä tilaa pääsee muokkaamaan vain "settereiden" avulla. Suunnittelumalli mahdollistaa sekä julkisten että yksityisten metodien ja muuttujien käytön. Isoissa projekteissa tämä pienentää todennäköisyyttä, että ohjelmoijien tahoillaan luomat rakenteet voisivat sekoittua toisten ohjelmoijien rakenteisiin. [8]</p>

<p>Seuraavassa esimerkki suunnittelumallista.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">testModule</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
	 
  <span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	 
  <span class="k">return</span> <span class="p">{</span>
	 
    <span class="nx">incrementCounter</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
	      <span class="k">return</span> <span class="nx">counter</span><span class="o">++</span><span class="p">;</span>
    <span class="p">},</span>
	 
    <span class="nx">resetCounter</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="s2">"counter value prior to reset: "</span> <span class="o">+</span> <span class="nx">counter</span> <span class="p">);</span>
      <span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>
	 
<span class="p">})();</span>

<span class="c1">// Increment our counter</span>
<span class="nx">testModule</span><span class="p">.</span><span class="nx">incrementCounter</span><span class="p">();</span>
</pre></div>

<p>Tässä <code>counter</code>-muuttujaan pääsee käsiksi ainoastaan moduulin palauttamien metodien avulla. Tämä suunnittelumalli on siis erityisesti edullinen julkisia rajapintoja luotaessa ja suurissa projekteissa, mutta toisaalta tällä ohjelmointityylillä häivytetään Javascriptille ominaista dynaamisuutta. Toki on edelleen niin, että jos <code>testModules</code> luodaan uusia ilmentymiä, niille voi asettaa omia kenttiä mielin määrin.</p>

<h3>
<a name="232-perint%C3%A4-javascriptiss%C3%A4" class="anchor" href="#232-perint%C3%A4-javascriptiss%C3%A4"><span class="octicon octicon-link"></span></a>2.3.2 Perintä Javascriptissä</h3>

<p>Olio-ohjelmoinnissa, kuten ohjelmoinnissa yleensäkin tulee vastaan tilanteita, joissa samanlaisia, tai miltei samanlaisia ohjelmanosia tarvitaan useassa kohdassa ohjelmakoodia. Helppo ratkaisu on kopioida tarvitut ohjelmanosat sinne missä niitä tarvitaan. Tämä on luonnollisestikin hyvän ohjelmointitavan vastaista ja onkin pyrittävä tekemään koodista mahdollisimman uudelleenkäytettävää. Perintä on yksi keino, jonka avulla voidaan välttyä kirjoittamasta jo kerran kirjoitettua koodia uudestaan. 
Javascriptissä käytetään prototyyppeihin perustuvaa perintää. </p>

<p>Javascriptillä voidaan myös toteuttaa moniperintä, jossa olio perii ominaisuuksia useilta muilta olioilta.</p>

<p>Esimerkki prototyyppiperinnästä, käyttäen Object.create funktiota. [4]</p>

<div class="highlight"><pre><span class="c1">// Shape - superclass</span>
<span class="k">function</span> <span class="n">Shape</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// superclass method</span>
<span class="n">Shape</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">move</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">console</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Shape moved."</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// Rectangle - subclass</span>
<span class="k">function</span> <span class="n">Rectangle</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Shape</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// call super constructor.</span>
<span class="p">}</span>

<span class="c1">// subclass extends superclass</span>
<span class="n">Rectangle</span><span class="p">.</span><span class="n">prototype</span> <span class="o">=</span> <span class="n">Object</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">Shape</span><span class="p">.</span><span class="n">prototype</span><span class="p">);</span>
<span class="n">Rectangle</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">constructor</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">;</span>

<span class="k">var</span> <span class="n">rect</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle</span><span class="p">();</span>

<span class="n">rect</span> <span class="n">instanceof</span> <span class="n">Rectangle</span> <span class="c1">// true.</span>
<span class="n">rect</span> <span class="n">instanceof</span> <span class="n">Shape</span> <span class="c1">// true.</span>

<span class="n">rect</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="mh">1</span><span class="p">,</span> <span class="mh">1</span><span class="p">);</span> <span class="c1">// Outputs, "Shape moved."</span>
</pre></div>

<p>Lähteet:</p>

<p>[1] <a href="http://bonsaiden.github.io/JavaScript-Garden/">http://bonsaiden.github.io/JavaScript-Garden/</a></p>

<p>[2] <a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a></p>

<p>[3] <a href="http://www.crockford.com/javascript/inheritance.html">http://www.crockford.com/javascript/inheritance.html</a></p>

<p>[4] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p>

<p>[5] <a href="http://stackoverflow.com/questions/5958417/javascript-function-and-object">http://stackoverflow.com/questions/5958417/javascript-function-and-object</a></p>

<p>[6] <a href="http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/">http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/</a></p>

<p>[7] <a href="http://en.wikipedia.org/wiki/GRASP_(object-oriented_design)">http://en.wikipedia.org/wiki/GRASP_(object-oriented_design)</a></p>

<p>[8] <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript">http://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript</a></p>

        <footer>
          Javascript is maintained by <a href="https://github.com/kxkyll">kxkyll</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
