
<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Javascript by kxkyll</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Javascript</h1>
          <h2>2. viikko</h2>
        </header>
	
	<p><em>Tekijät:</em> Marko Haanranta, Kasper Kivikataja,  Kati Kyllönen, Jussi Miestamo</p>

	<p>
		<a href="index.html">Pääsivu</a> <br />
		<a href="week2.html">2. viikko</a> <br />
		<a href="week3.html">3. viikko</a> <br />
		<a href="week4.html">4. viikko</a> <br />
	</p>
<pre>
	Viikko 2
1. Hyviä ohjelmointikäytäntöjä:
1.1 Tyyppiturvallisuuden tavoittelua

Tekijät: Marko Haanranta, Kati Kyllönen, Jussi Miestamo, Kasper Kivikataja

Javascriptissä muuttujat ja parametrit ovat tyypittömiä, mutta niiden arvoilla on tyypit. Javascriptin tietotyypit ovat merkkijono (string), luku (number), totuusarvo (boolean), taulukko (array), objekti (object), olematon (null) ja määrittelemätön (undefined). Vaikka muuttujilla ei olekaan tyyppiä, on arvojen tyyppejä syytä tarkistaa, jotta ohjelmat eivät tuottaisi odottamattomia tuloksia. Erityisesti käyttäjän syötteitä on hyvä tarkastella virheiden varalta. Javascriptissä yhteenlasku voidaan suorittaa ongelmitta luvun ja String-tyypin olion välillä.

function sum(a,b){return (a+b)}
write(sum(2,"w4"))                          //tulostaa "2w4"

Javascript tarjoaa - kuten tunnettua - funktiot parseInt() ja parseFloat() kokonais- tai liukulukujen eristämiseen syötteestä: jos syöte alkaa numerolla, siitä erotetaan numero-osa, ja loppu jätetään huomiotta. Joissain tapauksessa tämä on täysin riittävä tapa varmistaa se, että syöte on kelvollista. Jos ohjelmoija odottaa saavansa syötteenä esimerkiksi kokonaisluvun, vaaraa ei ole, koska parseInt() palauttaa aina kokonaisluvun tai tietotyypin undefined. Tietysti ohjelmakoodin pitää olla rakennettu niin, että undefined:iin on varauduttu, mutta käytettiin mitä tahansa keinoa tyyppien tarkastamiseen, Undefined:iin on joka tapauksessa aina varauduttava, jotta ohjelman toiminta olisi ennakoitavaa.

Vaikka yllä oleva esimerkki on yksinkertainen, pelkkä Undefined:iin varautuminen ei riitä. Koska oletettavaa on, että käyttäjä (tai funktiota kutsuva ohjelmoija) ei kirjoita syötteeseen lainausmerkkejä, esimerkin syötteen tekee kelvottomaksi todennäköisemmin käyttäjän lyöntivirhe:

write(sum(2,w4))                   //Tulostaa konsoliin ReferenceError: w4 is not defined;

Tällaisten tilanteiden varalta pitäisikin tarkistaa, onko syöte ylipäätään kokonaisluku. On onnekasta, jos syöte alkaa numeroilla, mutta jos ei ala, parseInt() ei pelasta.

Tyyppien tarkistus ohjelmakoodissa on erityisen tärkeää juuri käyttäjän syötettä käsiteltäessä...

Ehdotus kirjastofunktiosta tyyppitarkastusten tekemiseksi.

    Tarkastusfunktio onko muuttujassa arvo

function hasValue(value) {
    if(value){
        return true
    }
    return false
}

    Tarkastusfunktio numerolle

function isNumber(value) {
    return typeof value === 'number'
}

    Tarkastusfunktio kokonaisluvulle (jos value = 1.0, eli kun desimaaliosa on nolla, niin tulkitaan kokonaisluvuksi)

function isInteger(value) {
    return value === Math.floor(value)
}

    Tarkastusfunktio desimaaliluvulle (jos desimaaliosa on nolla, niin ei tulkita desimaaliluvuksi)

function isDouble (value) { 
    return typeof value === "number" && !isNaN(value) && value !== Math.floor(n)
}

se onko tälle käytännössä tarvetta, herätti keskustelua ryhmässämme. Toisaalta monet kirjastofunktiot tarjoavat usein palveluja, joiden käyttötarkoitusta voi vain arvailla.

    Tarkastusfunktio merkkijonolle (tässä tyhjä merkkijono tulkitaan merkkijonoksi)

function isString(value) {
    return typeof value === 'string'
}

    Tarkastusfunktio funktiolle

function isFunction(func) {
   var getType = {};
   return func && getType.toString.call(func) === '[object Function]';
}

    Tarkastusfunktio objektille

function isObject(object) {
   return typeof object === 'object';
}

    Tarkastusfunktio arraylle

function isArray(value) {
    return value instanceof Array;
}

    Tarkastusfunktio booleanille

function isBoolean(value) {
   return typeof value === 'boolean';
}

Esimerkkejä tyyppiturvallisuutta tavoittelevasta ohjelmointityylistä

Yleisen tason pohdiskelua tyyppiturvallisuuden tavoittelusta

Lomakkeiden validointi

    Javascript kuitenkin luotu nettisivuja varten, sikäli on siis hiukan keinotekoista yrittää irrottaa JS:ää html:stä. Tässä siksi siis puhutaan stringien validoinnin yhteydessä lomakkeista ja tietysti säännöllisistä lausekkeista.

Lähteet:

http://www.w3schools.com/js/js_datatypes.asp

http://www.cs.helsinki.fi/u/wikla/OTjs/materiaalia/tyyppeja/

http://united-coders.com/matthias-reuter/handling-the-unexpected-type-safe-functions-in-javascript/

</pre>
        <footer>
          Javascript is maintained by <a href="https://github.com/kxkyll">kxkyll</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
